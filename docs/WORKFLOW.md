# Q脑工作流程 (Q-Brain Workflow)

**版本:** 1.0  
**创建日期:** 2026-03-01  
**维护:** 项目管理委员会

---

## 🔄 整体工作流程

```
┌─────────────────────────────────────────────────────────────────┐
│                        Q脑 Agent 协作流程                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐ │
│  │ 任务接入 │───▶│ 任务分解 │───▶│ Agent分配│───▶│ 执行监控 │ │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘ │
│       │               │               │               │        │
│       ▼               ▼               ▼               ▼        │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐ │
│  │ 需求分析 │    │ 依赖识别 │    │ 负载均衡 │    │ 结果收集 │ │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘ │
│                                                                 │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐ │
│  │ 质量审查 │───▶│ 代码合并 │───▶│ 部署发布 │───▶│ 反馈优化 │ │
│  └──────────┘    └──────────┘    └──────────┘    └──────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 📋 任务分配机制

### 任务接入流程

```
1. 任务提交
   │
   ├── 来自用户直接指令
   ├── 来自定时任务调度
   ├── 来自事件触发 (告警/监控)
   └── 来自其他 Agent 请求
   │
   ▼
2. 任务登记 (Project Manager)
   │
   ├── 分配唯一任务 ID
   ├── 记录任务元数据
   ├── 评估优先级
   └── 估算工作量
   │
   ▼
3. 任务分析
   │
   ├── 识别任务类型
   ├── 分析依赖关系
   ├── 确定所需技能
   └── 评估复杂度
   │
   ▼
4. Agent 分配
   │
   ├── 查询可用 Agent
   ├── 匹配技能需求
   ├── 考虑负载均衡
   └── 分配执行 Agent
   │
   ▼
5. 执行与监控
   │
   ├── 任务执行
   ├── 进度上报
   ├── 异常处理
   └── 结果验证
```

### 任务类型分类

| 类型代码 | 类型名称 | 描述 | 适用 Agent |
|----------|----------|------|------------|
| DEV | 开发任务 | 新功能开发、代码实现 | Developer Agent |
| TEST | 测试任务 | 单元测试、集成测试 | QA Agent |
| DATA | 数据任务 | 数据处理、分析 | Data Agent |
| TRADE | 交易任务 | 订单执行、调仓 | Trading Agent |
| RISK | 风控任务 | 风险监控、预警 | Risk Agent |
| OPS | 运维任务 | 部署、监控、维护 | Ops Agent |
| DOC | 文档任务 | 文档编写、更新 | Documentation Agent |
| REVIEW | 审查任务 | 代码审查、设计评审 | Reviewer Agent |

---

## ⚖️ 负载均衡策略

### Agent 状态管理

每个 Agent 维护以下状态:

```python
class AgentState:
    agent_id: str           # Agent 唯一标识
    status: str             # IDLE, BUSY, OFFLINE
    current_tasks: list     # 当前执行任务列表
    max_concurrent: int     # 最大并发任务数
    skills: list            # 技能标签列表
    load_score: float       # 当前负载分数 (0-100)
    avg_task_time: float    # 平均任务耗时 (分钟)
    success_rate: float     # 任务成功率 (0-1)
    last_active: datetime   # 最后活跃时间
```

### 负载评分算法

```python
def calculate_load_score(agent: AgentState) -> float:
    """
    计算 Agent 负载分数 (0-100, 越低越好)
    """
    # 基础负载 (当前任务数 / 最大并发)
    base_load = (len(agent.current_tasks) / agent.max_concurrent) * 40
    
    # 时间负载 (考虑任务已执行时间)
    time_load = min(30, sum(task.elapsed_time for task in agent.current_tasks) / 60)
    
    # 历史表现 (成功率越低，负载分越高)
    performance_load = (1 - agent.success_rate) * 30
    
    return base_load + time_load + performance_load
```

### 任务分配算法

```python
def assign_task(task: Task, available_agents: list[AgentState]) -> AgentState:
    """
    为任务分配最优 Agent
    """
    # 1. 筛选符合技能要求的 Agent
    qualified_agents = [
        agent for agent in available_agents
        if has_required_skills(agent, task.required_skills)
        and agent.status == 'IDLE'
        and agent.load_score < 80
    ]
    
    if not qualified_agents:
        # 无可用 Agent，加入等待队列
        return None
    
    # 2. 按负载分数排序 (越低越好)
    qualified_agents.sort(key=lambda a: a.load_score)
    
    # 3. 考虑亲和性 (相同类型任务优先分配给最近执行过的 Agent)
    for agent in qualified_agents:
        if has_affinity(agent, task.type):
            return agent
    
    # 4. 返回负载最低的 Agent
    return qualified_agents[0]
```

### 负载均衡规则

| 规则 | 描述 | 触发条件 |
|------|------|----------|
| 阈值控制 | Agent 负载 > 80% 时不再分配新任务 | load_score > 80 |
| 溢出处理 | 所有 Agent 高负载时，任务进入等待队列 | 无可用 Agent |
| 抢占机制 | P0 任务可抢占低优先级任务资源 | P0 任务等待 > 5min |
| 动态扩容 | 等待队列 > 10 时，启动备用 Agent | queue_size > 10 |
| 缩容机制 | Agent 空闲 > 30min，进入休眠 | idle_time > 30min |

---

## 🔗 依赖关系管理

### 依赖类型

| 类型 | 符号 | 描述 | 示例 |
|------|------|------|------|
| 完成依赖 | → | B 必须等 A 完成后才能开始 | 测试→开发 |
| 开始依赖 | ⇒ | B 可以在 A 开始后就开始 | 文档⇒开发 |
| 数据依赖 | ⇢ | B 需要 A 产生的数据 | 分析⇢数据采集 |
| 资源依赖 | ⊸ | A 和 B 竞争同一资源 | 部署⊸测试环境 |

### 依赖图示例

```
M1: 基础架构
     │
     ▼
M2: 数据层 ──→ 数据接入 ──→ 数据清洗 ──→ 数据缓存
     │              │              │
     │              ▼              ▼
     │         财务数据        行情数据
     │
     ▼
M3: 策略引擎 ──→ 回测框架 ──→ 实盘引擎 ──→ OMS
     │              │              │
     ▼              ▼              ▼
M4: Agent 协作  绩效分析      订单执行    风险控制
```

### 依赖解析算法

```python
def resolve_dependencies(tasks: list[Task]) -> list[list[Task]]:
    """
    解析任务依赖，返回可并行执行的批次
    使用拓扑排序算法
    """
    # 构建依赖图
    graph = build_dependency_graph(tasks)
    
    # 计算入度
    in_degree = {task.id: 0 for task in tasks}
    for task in tasks:
        for dep in task.dependencies:
            in_degree[task.id] += 1
    
    # 拓扑排序
    batches = []
    remaining = set(tasks)
    
    while remaining:
        # 找出所有入度为 0 的任务 (可并行执行)
        batch = [t for t in remaining if in_degree[t.id] == 0]
        
        if not batch:
            raise CircularDependencyError("检测到循环依赖")
        
        batches.append(batch)
        
        # 移除已完成批次的依赖
        for task in batch:
            remaining.remove(task)
            for other in remaining:
                if task.id in other.dependencies:
                    in_degree[other.id] -= 1
    
    return batches
```

---

## 📊 进度跟踪系统

### 日报生成流程

```
每日 23:00 自动触发
     │
     ▼
1. 收集当日数据
   ├── 完成任务列表
   ├── 进行中任务状态
   ├── 代码提交统计
   ├── 测试覆盖率变化
   └── Bug 修复统计
     │
     ▼
2. 生成日报内容
   ├── 今日完成 (✅)
   ├── 进行中 (🔄)
   ├── 阻塞问题 (⚠️)
   ├── 明日计划 (📋)
   └── 风险提醒 (🔴)
     │
     ▼
3. 发送日报
   ├── 项目群通知
   ├── 邮件发送给相关人员
   └── 更新项目看板
```

### 日报模板

```markdown
# Q脑项目日报 [YYYY-MM-DD]

## ✅ 今日完成
- [任务 ID] 任务名称 - 负责人 - 状态
- ...

## 🔄 进行中
- [任务 ID] 任务名称 - 进度% - 预计完成时间
- ...

## ⚠️ 阻塞问题
- [问题描述] - 影响范围 - 需要协助
- ...

## 📋 明日计划
- [任务 ID] 任务名称 - 负责人
- ...

## 📈 关键指标
- 代码覆盖率: XX% (±X%)
- Bug 数量: X (新增 X, 修复 X)
- 构建成功率: XX%
- 系统可用性: XX%

## 🔴 风险提醒
- [风险描述] - 等级 - 应对措施
```

### 周报生成流程

```
每周一 09:00 自动触发
     │
     ▼
1. 汇总上周数据
   ├── 每日报告聚合
   ├── 里程碑进度
   ├── 资源消耗统计
   └── 质量指标趋势
     │
     ▼
2. 生成周报内容
   ├── 本周摘要
   ├── 里程碑进展
   ├── 关键成果
   ├── 问题与风险
   ├── 下周计划
   └── 资源需求
     │
     ▼
3. 周报评审与发送
   ├── PM 审核
   ├── 发送给项目组
   └── 存档
```

### 周报模板

```markdown
# Q脑项目周报 [YYYY-MM-DD ~ YYYY-MM-DD]

## 📌 本周摘要
本周整体进度：XX% (↑X%)
完成故事点：XX 点
投入工时：XX 人天

## 🎯 里程碑进展
| 里程碑 | 计划完成 | 预计完成 | 进度 | 状态 |
|--------|----------|----------|------|------|
| M1 | YYYY-MM-DD | YYYY-MM-DD | XX% | 🟢 |
| M2 | YYYY-MM-DD | YYYY-MM-DD | XX% | 🟡 |

## ✨ 关键成果
1. 成果描述
2. 成果描述
3. 成果描述

## ⚠️ 问题与风险
| 问题/风险 | 等级 | 影响 | 应对措施 | 负责人 |
|-----------|------|------|----------|--------|
| 描述 | 高/中/低 | 描述 | 措施 | 姓名 |

## 📋 下周计划
- [P0] 任务描述 - 负责人
- [P1] 任务描述 - 负责人
- [P2] 任务描述 - 负责人

## 📊 资源情况
- 人力投入：XX 人天 (可用: XX 人天)
- 计算资源：XX% 使用率
- 预算消耗：XX% (剩余: XX 元)
```

### 燃尽图数据

```python
class BurndownChart:
    def generate_data(self, sprint_start: date, sprint_end: date) -> dict:
        """
        生成燃尽图数据
        """
        total_days = (sprint_end - sprint_start).days + 1
        total_points = self.get_total_story_points()
        
        # 理想燃尽线
        ideal_line = [
            total_points - (total_points / total_days * day)
            for day in range(total_days)
        ]
        
        # 实际燃尽线 (每日剩余故事点)
        actual_line = [
            self.get_remaining_points(sprint_start + timedelta(days=day))
            for day in range(total_days)
        ]
        
        return {
            'dates': [(sprint_start + timedelta(days=i)).isoformat() 
                     for i in range(total_days)],
            'ideal': ideal_line,
            'actual': actual_line,
            'total_points': total_points,
            'completed_points': total_points - actual_line[-1]
        }
```

---

## 🎯 质量评估体系

### 代码审查清单

#### 基础检查 (必须通过)
- [ ] 代码通过所有单元测试
- [ ] 代码通过静态分析 (lint)
- [ ] 无安全漏洞 (SAST 扫描)
- [ ] 无敏感信息泄露
- [ ] 遵循代码规范

#### 功能检查
- [ ] 功能符合需求描述
- [ ] 边界条件处理完整
- [ ] 异常处理完善
- [ ] 日志记录充分
- [ ] 配置项外部化

#### 性能检查
- [ ] 无明显的性能问题
- [ ] 数据库查询有索引
- [ ] 无内存泄漏风险
- [ ] 缓存使用合理
- [ ] 异步处理适当

#### 可维护性检查
- [ ] 代码可读性好
- [ ] 函数职责单一
- [ ] 命名清晰准确
- [ ] 注释必要且准确
- [ ] 文档同步更新

#### 测试检查
- [ ] 单元测试覆盖率达标
- [ ] 关键路径有集成测试
- [ ] 边界条件有测试覆盖
- [ ] 异常场景有测试覆盖

### 审查流程

```
1. 开发者提交 PR
   │
   ▼
2. 自动化检查
   ├── CI 构建
   ├── 单元测试
   ├── 代码扫描
   └── 覆盖率检查
   │
   ▼
3. 自动审查通过?
   │
   ├── 否 ──▶ 返回修改
   │
   └── 是
        │
        ▼
4. 人工审查 (至少 1 人)
   ├── 功能审查
   ├── 代码质量审查
   └── 审查意见
   │
   ▼
5. 修改与再审
   │
   ├── 有修改 ──▶ 重新审查
   │
   └── 无修改/通过
        │
        ▼
6. 合并到主分支
```

### 测试覆盖率要求

| 模块类型 | 行覆盖率 | 分支覆盖率 | 关键路径 |
|----------|----------|------------|----------|
| 核心交易 | ≥ 90% | ≥ 85% | 100% |
| 风险控制 | ≥ 90% | ≥ 85% | 100% |
| 数据处理 | ≥ 85% | ≥ 80% | 100% |
| 策略引擎 | ≥ 85% | ≥ 80% | 100% |
| 工具函数 | ≥ 80% | ≥ 75% | 100% |
| 接口层 | ≥ 80% | ≥ 75% | 100% |
| UI 组件 | ≥ 70% | ≥ 65% | 关键路径 |

### 性能基准

#### 交易性能
| 指标 | 目标值 | 警告值 | 严重值 |
|------|--------|--------|--------|
| 订单延迟 | < 50ms | < 100ms | < 200ms |
| 行情处理 | < 10ms | < 20ms | < 50ms |
| 策略计算 | < 100ms | < 200ms | < 500ms |
| 风控检查 | < 20ms | < 50ms | < 100ms |

#### 系统性能
| 指标 | 目标值 | 警告值 | 严重值 |
|------|--------|--------|--------|
| API 响应 | < 100ms | < 200ms | < 500ms |
| 数据库查询 | < 50ms | < 100ms | < 200ms |
| 数据写入 | < 100ms | < 200ms | < 500ms |
| 系统可用性 | > 99.9% | > 99.5% | > 99% |

#### 数据处理性能
| 指标 | 目标值 | 警告值 | 严重值 |
|------|--------|--------|--------|
| 数据接入延迟 | < 1s | < 5s | < 10s |
| 批量处理速度 | > 1万条/s | > 5千条/s | > 1千条/s |
| 回测速度 | > 10年/min | > 5年/min | > 1年/min |

---

## 🚨 异常处理流程

### 异常分级

| 等级 | 名称 | 响应时间 | 处理流程 |
|------|------|----------|----------|
| P0 | 严重 | 5 分钟内 | 全员响应，立即修复 |
| P1 | 高 | 30 分钟内 | 相关负责人处理 |
| P2 | 中 | 2 小时内 | 记录并安排处理 |
| P3 | 低 | 24 小时内 | 纳入待办事项 |

### 异常上报流程

```
异常发生
   │
   ▼
自动检测/人工发现
   │
   ▼
异常定级
   │
   ├── P0 ──▶ 电话通知 + 群公告 + 邮件
   ├── P1 ──▶ 群公告 + 邮件
   ├── P2 ──▶ 邮件 + 任务系统
   └── P3 ──▶ 任务系统
   │
   ▼
异常处理
   │
   ├── 临时措施 (如有)
   ├── 根因分析
   ├── 永久修复
   └── 验证关闭
   │
   ▼
事后复盘
   │
   ├── 编写事故报告
   ├── 制定预防措施
   └── 更新文档/流程
```

---

## 📝 文档规范

### 文档类型

| 类型 | 位置 | 更新频率 | 负责人 |
|------|------|----------|--------|
| 架构文档 | docs/architecture/ | 季度 | 架构师 |
| API 文档 | docs/api/ | 随代码 | 开发者 |
| 用户手册 | docs/user-guide/ | 月度 | 产品 |
| 运维手册 | docs/ops/ | 季度 | 运维 |
| 开发规范 | docs/standards/ | 半年 | Tech Lead |

### 文档模板

所有文档应包含:
- 文档标题和版本
- 创建/更新日期
- 作者/维护者
- 目录 (超过 5 节时)
- 变更记录

---

## 🔄 持续改进

### 回顾会议

**频率:** 每迭代结束 (2 周)

**议程:**
1. 本迭代完成情况回顾
2. 做得好的地方 (Keep)
3. 需要改进的地方 (Improve)
4. 需要停止的做法 (Stop)
5. 下迭代行动计划

### 改进跟踪

```
改进建议
   │
   ▼
评估优先级
   │
   ▼
纳入待办事项
   │
   ▼
分配负责人
   │
   ▼
跟踪实施
   │
   ▼
验证效果
```

---

**文档维护:** 项目管理委员会  
**最后更新:** 2026-03-01  
**下次评审:** 2026-04-01
