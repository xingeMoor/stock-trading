# Q脑系统技术栈说明

## 1. 核心技术选型决策

### 1.1 数据库选型

#### 决策：**PostgreSQL + InfluxDB + Redis** 组合方案

| 数据类型 | 数据库 | 理由 |
|---------|--------|------|
| 关系型数据 | PostgreSQL | ACID 事务、复杂查询、成熟稳定 |
| 时序数据 | InfluxDB | 高性能写入、时序聚合、数据保留策略 |
| 缓存数据 | Redis | 内存缓存、Pub/Sub、数据结构丰富 |
| 文档数据 | PostgreSQL (JSONB) | 无需额外引入 MongoDB，JSONB 足够灵活 |

**详细理由**:

**PostgreSQL** (主数据库):
- ✅ 支持复杂 SQL 查询和 JOIN 操作
- ✅ JSONB 类型支持半结构化数据存储
- ✅ 成熟的生态和工具链
- ✅ 强大的扩展能力 (TimescaleDB 插件)
- ✅ 社区活跃，长期支持
- ❌ 时序数据写入性能不如专业时序数据库

**InfluxDB** (时序数据库):
- ✅ 专为时序数据优化，写入性能极高
- ✅ 内置时序函数 (移动平均、指数平滑等)
- ✅ 自动数据保留和降采样
- ✅ 原生支持标签查询
- ❌ 复杂查询能力弱于 PostgreSQL
- ❌ 生态相对较小

**Redis** (缓存 + 消息):
- ✅ 内存操作，极低延迟 (<1ms)
- ✅ 支持 Pub/Sub 消息模式
- ✅ 丰富的数据结构 (Hash, List, Set, SortedSet)
- ✅ 支持持久化 (RDB+AOF)
- ❌ 内存成本高，不适合大量数据存储

**为什么不选 MongoDB**:
- 量化交易需要大量数值计算和聚合查询，关系型数据库更合适
- PostgreSQL 的 JSONB 已经能满足文档存储需求
- 减少技术栈复杂度，降低运维成本

**为什么不选 SQLite**:
- 仅适合开发和单机场景
- 不支持并发写入
- 缺乏高可用和分布式能力

---

### 1.2 缓存策略

#### 决策：**三级缓存架构**

```
┌─────────────────────────────────────────────────────────┐
│                    应用层                                │
│  ┌─────────────────────────────────────────────────┐    │
│  │              L1: 进程内缓存 (内存)               │    │
│  │         热点数据、配置信息、会话状态              │    │
│  │              失效策略：LRU + TTL                 │    │
│  └─────────────────────────────────────────────────┘    │
│                          ↓                               │
│  ┌─────────────────────────────────────────────────┐    │
│  │              L2: Redis 分布式缓存                │    │
│  │    共享数据、行情快照、策略状态、信号缓存         │    │
│  │              失效策略：TTL + 事件驱动            │    │
│  └─────────────────────────────────────────────────┘    │
│                          ↓                               │
│  ┌─────────────────────────────────────────────────┐    │
│  │              L3: 文件缓存 (本地 SSD)             │    │
│  │      历史数据、大文件、不常变动的静态数据          │    │
│  │              失效策略：手动 + 定期清理           │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

**缓存内容规划**:

| 缓存层级 | 缓存内容 | 更新频率 | 失效策略 |
|---------|---------|---------|---------|
| L1 内存 | 配置参数、用户会话、临时计算结果 | 实时 | LRU + 5min TTL |
| L2 Redis | 实时行情、策略状态、信号队列 | 秒级 | 事件驱动 + 1h TTL |
| L3 文件 | 历史 K 线、财务数据、因子库 | 日级 | 手动更新 |

**缓存一致性保证**:
- 写操作：先写数据库，再删除缓存 (Cache-Aside)
- 读操作：先查缓存，未命中则查库并回填
- 关键数据：使用分布式锁保证并发安全

---

### 1.3 消息队列选型

#### 决策：**Redis Streams + Kafka** 分层方案

**场景分析**:

| 场景 | 技术选型 | 理由 |
|-----|---------|------|
| 实时信号传递 | Redis Streams | 低延迟、简单部署、足够可靠 |
| 事件日志归档 | Kafka | 高吞吐、持久化、可回溯 |
| 任务队列 | Redis List | 简单任务、APScheduler 集成 |
| 异步批处理 | Celery + Redis | 复杂任务、定时任务、重试机制 |

**架构设计**:
```
┌─────────────────────────────────────────────────────────────┐
│                      消息层                                  │
│                                                              │
│  ┌─────────────────┐          ┌─────────────────┐           │
│  │  Redis Streams  │          │      Kafka      │           │
│  │  (实时消息)      │          │   (事件日志)     │           │
│  │                 │          │                 │           │
│  │ - 交易信号       │          │ - 操作审计       │           │
│  │ - 行情推送       │          │ - 系统事件       │           │
│  │ - 告警通知       │          │ - 绩效数据       │           │
│  └─────────────────┘          └─────────────────┘           │
│                                                              │
│  ┌─────────────────────────────────────────────────┐        │
│  │              Celery (任务队列)                   │        │
│  │                                                 │        │
│  │ - 定时数据更新    - 批量回测任务                  │        │
│  │ - 报告生成        - 数据清洗                      │        │
│  └─────────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

**为什么不全用 Kafka**:
- Kafka 部署复杂，运维成本高
- 对于低延迟场景 (<10ms)，Redis 更优
- 系统初期规模不需要 Kafka 的吞吐量

**什么时候迁移到全 Kafka**:
- 消息量 > 100 万条/分钟
- 需要严格的消息顺序保证
- 需要消息回溯和重放能力

---

### 1.4 任务调度选型

#### 决策：**APScheduler + Celery** 组合方案

**APScheduler** (轻量级调度):
```python
# 适用场景：单机、简单定时任务
from apscheduler.schedulers.asyncio import AsyncIOScheduler

scheduler = AsyncIOScheduler()

# 定时采集数据
scheduler.add_job(
    fetch_market_data,
    'cron',
    hour='*',
    minute='0,30',
    id='market_data_fetch'
)

# 日终任务
scheduler.add_job(
    daily_settlement,
    'cron',
    hour='17',
    minute='30',
    id='daily_settlement'
)
```

**Celery** (分布式任务):
```python
# 适用场景：分布式、复杂任务、需要重试
from celery import Celery

app = Celery('qbrain', broker='redis://localhost:6379/0')

@app.task(bind=True, max_retries=3)
def run_backtest(self, strategy_id, start_date, end_date):
    try:
        return execute_backtest(strategy_id, start_date, end_date)
    except Exception as exc:
        raise self.retry(exc=exc, countdown=60)
```

**选型对比**:

| 特性 | APScheduler | Celery | 选择 |
|-----|-------------|--------|------|
| 部署复杂度 | 低 | 中 | 简单场景选 APS |
| 分布式支持 | 否 | 是 | 分布式选 Celery |
| 任务持久化 | 可选 | 是 | 重要任务选 Celery |
| 重试机制 | 简单 | 完善 | 需要重试选 Celery |
| 监控能力 | 弱 | 强 (Flower) | 需要监控选 Celery |
| 资源消耗 | 低 | 中 | 资源敏感选 APS |

**最终方案**:
- 开发环境：仅使用 APScheduler
- 生产环境：APScheduler (定时) + Celery (异步任务)

---

### 1.5 Web 框架选型

#### 决策：**FastAPI**

**理由**:
- ✅ 原生异步支持，高性能
- ✅ 自动生成 OpenAPI 文档
- ✅ 类型提示，代码质量高
- ✅ 依赖注入，易于测试
- ✅ 社区活跃，生态丰富
- ✅ 学习曲线平缓

**对比**:
- Flask: 同步框架，性能较低
- Django: 太重，不适合 API 服务
- Sanic: 社区较小，生态不如 FastAPI

---

### 1.6 其他关键技术选型

| 组件 | 选型 | 理由 |
|-----|------|------|
| ORMs | SQLAlchemy 2.0 | 成熟稳定、支持异步、类型安全 |
| 数据验证 | Pydantic v2 | FastAPI 原生支持、性能好 |
| 日志 | structlog + Loguru | 结构化日志、开发体验好 |
| 配置管理 | Pydantic Settings | 类型安全、支持多环境 |
| 测试 | pytest + pytest-asyncio | 生态完善、异步支持 |
| 容器化 | Docker + K8s | 行业标准、易于部署 |
| CI/CD | GitHub Actions | 免费、集成好 |
| 监控 | Prometheus + Grafana | 开源、生态完善 |
| 追踪 | Jaeger | 分布式追踪、开源 |

---

## 2. 技术栈总览

### 2.1 后端技术栈

```
┌─────────────────────────────────────────────────────────────┐
│                      应用层                                  │
│                                                              │
│  语言：Python 3.11+                                         │
│  Web 框架：FastAPI                                           │
│  异步：asyncio + aiohttp                                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据层                                  │
│                                                              │
│  ORM: SQLAlchemy 2.0 (Async)                                │
│  验证：Pydantic v2                                          │
│  迁移：Alembic                                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                     存储层                                   │
│                                                              │
│  PostgreSQL 15+  (关系型数据)                                │
│  InfluxDB 2.x    (时序数据)                                  │
│  Redis 7.x       (缓存 + 消息)                               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                     基础设施                                 │
│                                                              │
│  容器：Docker + Kubernetes                                  │
│  消息：Redis Streams + Kafka                                │
│  调度：APScheduler + Celery                                 │
│  监控：Prometheus + Grafana                                 │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 开发工具链

```
代码管理：Git + GitHub
代码质量：ruff + mypy + black
测试：pytest + coverage
文档：MkDocs + mkdocstrings
依赖：uv (超快 Python 包管理器)
虚拟环境：venv
```

### 2.3 量化专用库

```
数据处理：pandas + numpy + polars (可选)
技术分析：ta-lib + pandas-ta
回测引擎：vectorbt / 自研
机器学习：scikit-learn + xgboost + pytorch
优化算法：scipy + cvxpy
```

---

## 3. 版本规划

### Phase 1 (MVP - 1个月)
- [x] 基础架构搭建
- [ ] PostgreSQL + Redis 集成
- [ ] FastAPI 骨架
- [ ] 基础数据采集
- [ ] 简单策略回测

### Phase 2 (Alpha - 2个月)
- [ ] 完整数据层
- [ ] 策略引擎 v1
- [ ] 模拟交易
- [ ] 基础监控

### Phase 3 (Beta - 3个月)
- [ ] 实盘交易对接
- [ ] 风控系统
- [ ] 完整监控告警
- [ ] 性能优化

### Phase 4 (Production - 6个月)
- [ ] 高可用部署
- [ ] 多市场支持
- [ ] 策略市场
- [ ] 完整文档

---

## 4. 技术债务管理

### 已知权衡
1. **Redis vs Kafka**: 初期用 Redis，消息量大时迁移 Kafka
2. **单体 vs 微服务**: 初期单体，模块清晰后拆分
3. **自研 vs 开源**: 核心策略自研，基础设施用开源

### 重构触发条件
- 单表数据量 > 1 亿行 → 考虑分库分表
- API P99 延迟 > 500ms → 性能优化/缓存
- 代码重复率 > 15% → 重构
- 测试覆盖率 < 80% → 补充测试

---

*文档版本：v1.0*
*最后更新：2026-03-01*
*作者：Archie (架构师)*
