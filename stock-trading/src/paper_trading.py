"""
æ¨¡æ‹Ÿäº¤æ˜“è¿è¡Œå™¨
æ¯æ—¥è‡ªåŠ¨æ‰§è¡Œï¼šè·å–æ•°æ® â†’ ç­–ç•¥å†³ç­– â†’ æ‰§è¡Œäº¤æ˜“ â†’ è®°å½•ä¿å­˜
"""
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import json
import os

from .config import BACKTEST_CONFIG, MASSIVE_API_KEY
from .massive_api import get_real_time_data, get_all_indicators, get_market_status
from .trading_db import TradingDatabase
from strategies.relaxed_strategy import relaxed_strategy
from strategies.optimized_v2_strategy import optimized_v2_strategy


class PaperTradingRunner:
    """
    æ¨¡æ‹Ÿäº¤æ˜“è¿è¡Œå™¨
    
    åŠŸèƒ½:
    1. æ¯æ—¥è‡ªåŠ¨è·å–å¸‚åœºæ•°æ®
    2. æ‰§è¡Œç­–ç•¥å†³ç­–
    3. æ¨¡æ‹Ÿäº¤æ˜“æ‰§è¡Œ
    4. è®°å½•åˆ°æ•°æ®åº“
    5. ç”Ÿæˆæ¯æ—¥æŠ¥å‘Š
    """
    
    def __init__(self, initial_capital: float = 10000.0, 
                 strategy_name: str = "optimized_v2",
                 position_size_pct: float = 0.3,
                 db_path: str = None):
        """
        åˆå§‹åŒ–æ¨¡æ‹Ÿäº¤æ˜“è¿è¡Œå™¨
        
        Args:
            initial_capital: åˆå§‹èµ„é‡‘
            strategy_name: ç­–ç•¥åç§° (relaxed/optimized_v2)
            position_size_pct: å•ç¬”äº¤æ˜“ä»“ä½æ¯”ä¾‹ (0.3 = 30%)
            db_path: æ•°æ®åº“è·¯å¾„
        """
        self.initial_capital = initial_capital
        self.strategy_name = strategy_name
        self.position_size_pct = position_size_pct
        self.db = TradingDatabase(db_path)
        
        # é€‰æ‹©ç­–ç•¥
        if strategy_name == "relaxed":
            self.strategy_func = relaxed_strategy
        elif strategy_name == "optimized_v2":
            self.strategy_func = optimized_v2_strategy
        else:
            raise ValueError(f"æœªçŸ¥ç­–ç•¥ï¼š{strategy_name}")
        
        # äº¤æ˜“é…ç½®
        self.commission_rate = 0.001  # 0.1%
        self.slippage = 0.0005  # 0.05%
    
    def get_current_capital(self) -> float:
        """è·å–å½“å‰å¯ç”¨èµ„é‡‘"""
        snapshot = self.db.get_latest_snapshot()
        
        if snapshot is None:
            return self.initial_capital
        
        # å¯ç”¨èµ„é‡‘ = æ€»èµ„é‡‘ - æŒä»“å¸‚å€¼
        return snapshot['cash']
    
    def get_current_positions(self) -> List[Dict]:
        """è·å–å½“å‰æŒä»“"""
        return self.db.get_positions()
    
    def execute_daily_trading(self, symbols: List[str], 
                              trading_date: str = None) -> Dict[str, Any]:
        """
        æ‰§è¡Œæ¯æ—¥äº¤æ˜“
        
        Args:
            symbols: å¾…äº¤æ˜“çš„è‚¡ç¥¨åˆ—è¡¨
            trading_date: äº¤æ˜“æ—¥æœŸ (é»˜è®¤ä»Šå¤©)
        
        Returns:
            äº¤æ˜“æ‰§è¡ŒæŠ¥å‘Š
        """
        if trading_date is None:
            trading_date = datetime.now().strftime('%Y-%m-%d')
        
        print(f"\n{'='*60}")
        print(f"ğŸ“… æ¨¡æ‹Ÿäº¤æ˜“æ‰§è¡Œ - {trading_date}")
        print(f"{'='*60}")
        
        # 1. æ£€æŸ¥å¸‚åœºçŠ¶æ€
        market_status = get_market_status()
        if market_status.get('status') == 'closed':
            print(f"âš ï¸  å¸‚åœºå·²å…³é—­ï¼Œä½¿ç”¨æœ€æ–°æ•°æ®")
        
        # 2. è·å–å½“å‰è´¦æˆ·çŠ¶æ€
        cash = self.get_current_capital()
        positions = self.get_current_positions()
        
        print(f"\nğŸ’° è´¦æˆ·çŠ¶æ€:")
        print(f"  å¯ç”¨èµ„é‡‘ï¼š${cash:,.2f}")
        print(f"  å½“å‰æŒä»“ï¼š{len(positions)} åª")
        
        # 3. æ›´æ–°æŒä»“ä»·æ ¼
        print(f"\nâ³ æ›´æ–°æŒä»“ä»·æ ¼...")
        for pos in positions:
            symbol = pos['symbol']
            try:
                data = get_real_time_data(symbol)
                if 'error' not in data:
                    current_price = data['price']
                    self.db.update_position(
                        symbol=symbol,
                        shares=pos['shares'],
                        average_cost=pos['average_cost'],
                        current_price=current_price
                    )
                    pnl = (current_price - pos['average_cost']) * pos['shares']
                    print(f"  {symbol}: ${current_price:.2f}, ç›ˆäºï¼š${pnl:+,.2f}")
            except Exception as e:
                print(f"  âŒ {symbol} æ›´æ–°å¤±è´¥ï¼š{e}")
        
        # 4. æ‰§è¡Œäº¤æ˜“å†³ç­–
        executed_trades = []
        
        print(f"\nğŸ¤– æ‰§è¡Œäº¤æ˜“å†³ç­–...")
        for symbol in symbols:
            try:
                trade_result = self._execute_symbol_decision(symbol, cash, positions, trading_date)
                if trade_result:
                    executed_trades.append(trade_result)
                    
                    # æ›´æ–°å¯ç”¨èµ„é‡‘
                    if trade_result['trade_type'] == 'buy':
                        cash -= trade_result['value'] + trade_result['commission']
                    else:
                        cash += trade_result['value'] - trade_result['commission']
                
            except Exception as e:
                print(f"  âŒ {symbol} å†³ç­–å¤±è´¥ï¼š{e}")
        
        # 5. è®¡ç®—è´¦æˆ·æ€»å€¼
        positions = self.get_current_positions()
        position_value = sum(pos['market_value'] for pos in positions)
        total_value = cash + position_value
        
        # 6. ä¿å­˜æ¯æ—¥å¿«ç…§
        self.db.add_snapshot(
            total_capital=self.initial_capital,
            cash=cash,
            position_value=position_value
        )
        
        # 7. ç”ŸæˆæŠ¥å‘Š
        report = {
            'trading_date': trading_date,
            'executed_trades': executed_trades,
            'account_summary': {
                'cash': round(cash, 2),
                'position_value': round(position_value, 2),
                'total_value': round(total_value, 2),
                'total_return': round(total_value - self.initial_capital, 2),
                'total_return_pct': round((total_value - self.initial_capital) / self.initial_capital * 100, 2)
            },
            'positions': positions,
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # 8. æ‰“å°æŠ¥å‘Š
        self._print_report(report)
        
        return report
    
    def _execute_symbol_decision(self, symbol: str, cash: float, 
                                  positions: List[Dict], 
                                  trading_date: str) -> Optional[Dict]:
        """
        æ‰§è¡Œå•åªè‚¡ç¥¨çš„äº¤æ˜“å†³ç­–
        
        Returns:
            äº¤æ˜“è®°å½• (å¦‚æœæœ‰æ‰§è¡Œ)
        """
        # è·å–æ•°æ®
        data = get_real_time_data(symbol)
        if 'error' in data:
            print(f"  âš ï¸  {symbol} æ•°æ®è·å–å¤±è´¥ï¼š{data.get('error')}")
            return None
        
        indicators = get_all_indicators(symbol)
        if 'error' in indicators:
            print(f"  âš ï¸  {symbol} æŒ‡æ ‡è·å–å¤±è´¥")
            return None
        
        # æ„å»ºç­–ç•¥éœ€è¦çš„æ•°æ®æ ¼å¼
        class MockRow:
            def __init__(self, data):
                self.close = data.get('price', 0)
                self.open = data.get('open', 0)
                self.high = data.get('high', 0)
                self.low = data.get('low', 0)
                self.volume = data.get('volume', 0)
        
        row = MockRow(data)
        current_indicators = {
            'current_price': data.get('price', 0),
            'current_date': trading_date,
            **indicators
        }
        
        # è·å–å½“å‰æŒä»“
        current_position = None
        for pos in positions:
            if pos['symbol'] == symbol:
                current_position = pos
                break
        
        # æ‰§è¡Œç­–ç•¥
        try:
            signal = self.strategy_func(row, current_indicators, symbol)
        except TypeError:
            # å‘åå…¼å®¹
            signal = self.strategy_func(row, current_indicators)
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦äº¤æ˜“
        if signal == 'hold':
            print(f"  â¸ï¸  {symbol}: æŒæœ‰")
            return None
        
        # æ‰§è¡Œäº¤æ˜“
        current_price = data['price']
        
        if signal == 'buy' and current_position is None:
            # ä¹°å…¥
            available_cash = cash * self.position_size_pct
            shares = int(available_cash / (current_price * (1 + self.slippage + self.commission_rate)))
            
            if shares <= 0:
                print(f"  âš ï¸  {symbol}: èµ„é‡‘ä¸è¶³")
                return None
            
            effective_price = current_price * (1 + self.slippage)
            value = shares * effective_price
            commission = value * self.commission_rate
            
            # è®°å½•äº¤æ˜“
            trade_id = self.db.add_trade(
                symbol=symbol,
                trade_type='buy',
                price=effective_price,
                shares=shares,
                strategy=self.strategy_name,
                confidence=0.75,  # å¯ä»¥ä¼ ç»™ç­–ç•¥è®¡ç®—
                reasoning=f"{signal} signal"
            )
            
            # æ›´æ–°æŒä»“
            self.db.update_position(
                symbol=symbol,
                shares=shares,
                average_cost=effective_price,
                current_price=effective_price
            )
            
            print(f"  â†’ {symbol}: BUY {shares}è‚¡ @ ${effective_price:.2f}")
            
            return {
                'trade_id': trade_id,
                'symbol': symbol,
                'trade_type': 'buy',
                'price': effective_price,
                'shares': shares,
                'value': value,
                'commission': commission
            }
        
        elif signal == 'sell' and current_position is not None:
            # å–å‡º
            shares = current_position['shares']
            effective_price = current_price * (1 - self.slippage)
            value = shares * effective_price
            commission = value * self.commission_rate
            pnl = (effective_price - current_position['average_cost']) * shares
            
            # è®°å½•äº¤æ˜“
            trade_id = self.db.add_trade(
                symbol=symbol,
                trade_type='sell',
                price=effective_price,
                shares=shares,
                strategy=self.strategy_name,
                confidence=0.75,
                reasoning=f"{signal} signal",
                pnl=pnl
            )
            
            # æ¸…é™¤æŒä»“
            self.db.clear_position(symbol)
            
            print(f"  â† {symbol}: SELL {shares}è‚¡ @ ${effective_price:.2f}, PnL: ${pnl:+,.2f}")
            
            return {
                'trade_id': trade_id,
                'symbol': symbol,
                'trade_type': 'sell',
                'price': effective_price,
                'shares': shares,
                'value': value,
                'commission': commission,
                'pnl': pnl
            }
        
        return None
    
    def _print_report(self, report: Dict[str, Any]):
        """æ‰“å°äº¤æ˜“æŠ¥å‘Š"""
        print(f"\n{'='*60}")
        print(f"ğŸ“Š äº¤æ˜“æŠ¥å‘Š")
        print(f"{'='*60}")
        
        # è´¦æˆ·æ‘˜è¦
        summary = report['account_summary']
        print(f"\nğŸ’° è´¦æˆ·æ‘˜è¦:")
        print(f"  ç°é‡‘ï¼š      ${summary['cash']:>12,.2f}")
        print(f"  æŒä»“å¸‚å€¼ï¼š  ${summary['position_value']:>12,.2f}")
        print(f"  æ€»èµ„äº§ï¼š    ${summary['total_value']:>12,.2f}")
        print(f"  æ€»æ”¶ç›Šï¼š    ${summary['total_return']:>12,.2f} ({summary['total_return_pct']:+.2f}%)")
        
        #  executed trades
        trades = report['executed_trades']
        if trades:
            print(f"\nğŸ“ ä»Šæ—¥äº¤æ˜“:")
            for trade in trades:
                arrow = "â†’" if trade['trade_type'] == 'buy' else "â†"
                pnl_str = f" (PnL: ${trade['pnl']:+,.2f})" if trade['trade_type'] == 'sell' else ""
                print(f"  {arrow} {trade['symbol']}: {trade['shares']}è‚¡ @ ${trade['price']:.2f}{pnl_str}")
        else:
            print(f"\nğŸ“ ä»Šæ—¥äº¤æ˜“ï¼šæ— ")
        
        # æŒä»“
        positions = report['positions']
        if positions:
            print(f"\nğŸ“ˆ å½“å‰æŒä»“:")
            for pos in positions:
                pnl_pct = pos['unrealized_pnl_pct']
                print(f"  {pos['symbol']}: {pos['shares']}è‚¡, ç›ˆäºï¼š${pos['unrealized_pnl']:+,.2f} ({pnl_pct:+.2f}%)")
        
        print(f"\n{'='*60}\n")
    
    def get_performance_report(self, start_date: str = None, 
                                end_date: str = None) -> Dict[str, Any]:
        """
        è·å–ç»©æ•ˆæŠ¥å‘Š
        
        Args:
            start_date: å¼€å§‹æ—¥æœŸ
            end_date: ç»“æŸæ—¥æœŸ
        
        Returns:
            ç»©æ•ˆæŠ¥å‘Š
        """
        snapshots = self.db.get_snapshots(start_date=start_date, end_date=end_date, limit=1000)
        statistics = self.db.get_statistics()
        
        if not snapshots:
            return {'error': 'æ— æ•°æ®'}
        
        # è®¡ç®—ç»©æ•ˆæŒ‡æ ‡
        values = [s['total_value'] for s in reversed(snapshots)]
        
        import numpy as np
        
        # æ”¶ç›Šç‡
        total_return = (values[-1] - values[0]) / values[0] * 100
        
        # æ—¥æ”¶ç›Šç‡
        daily_returns = np.diff(values) / values[:-1]
        
        # å¹´åŒ–æ”¶ç›Šç‡ (å‡è®¾ 252 äº¤æ˜“æ—¥)
        trading_days = len(values)
        annual_return = (values[-1] / values[0]) ** (252 / trading_days) - 1 if trading_days > 0 else 0
        
        # æ³¢åŠ¨ç‡
        volatility = np.std(daily_returns) * np.sqrt(252) if len(daily_returns) > 0 else 0
        
        # å¤æ™®æ¯”ç‡ (å‡è®¾æ— é£é™©åˆ©ç‡ 0)
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0
        
        # æœ€å¤§å›æ’¤
        cummax = np.maximum.accumulate(values)
        drawdown = (np.array(values) - cummax) / cummax
        max_drawdown = np.min(drawdown) * 100
        
        return {
            'period': {
                'start': snapshots[-1]['snapshot_date'] if snapshots else None,
                'end': snapshots[0]['snapshot_date'] if snapshots else None,
                'trading_days': len(snapshots)
            },
            'returns': {
                'total_return_pct': round(total_return, 2),
                'annual_return_pct': round(annual_return * 100, 2),
                'volatility_pct': round(volatility * 100, 2),
                'sharpe_ratio': round(sharpe_ratio, 2),
                'max_drawdown_pct': round(max_drawdown, 2)
            },
            'statistics': statistics,
            'daily_values': [
                {
                    'date': s['snapshot_date'],
                    'total_value': s['total_value'],
                    'daily_return_pct': s['daily_return_pct']
                } for s in reversed(snapshots)
            ]
        }
    
    def export_report(self, output_path: str):
        """å¯¼å‡ºç»©æ•ˆæŠ¥å‘Šåˆ°æ–‡ä»¶"""
        report = self.get_performance_report()
        
        with open(output_path, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        print(f"âœ“ ç»©æ•ˆæŠ¥å‘Šå·²å¯¼å‡ºï¼š{output_path}")


def run_paper_trading(symbols: List[str], initial_capital: float = 10000.0,
                      strategy: str = "optimized_v2", position_size: float = 0.3):
    """
    ä¾¿æ·å‡½æ•°ï¼šè¿è¡Œæ¨¡æ‹Ÿäº¤æ˜“
    
    Args:
        symbols: è‚¡ç¥¨åˆ—è¡¨
        initial_capital: åˆå§‹èµ„é‡‘
        strategy: ç­–ç•¥åç§°
        position_size: ä»“ä½æ¯”ä¾‹
    """
    runner = PaperTradingRunner(
        initial_capital=initial_capital,
        strategy_name=strategy,
        position_size_pct=position_size
    )
    
    return runner.execute_daily_trading(symbols)


if __name__ == "__main__":
    # æµ‹è¯•è¿è¡Œ
    symbols = ["GOOGL", "META", "AAPL"]
    
    report = run_paper_trading(
        symbols=symbols,
        initial_capital=10000,
        strategy="optimized_v2",
        position_size=0.3
    )
    
    print(json.dumps(report, indent=2, default=str))
